/*
 * jdec.c
 * Autogenerated code from TrainFramework
 *  Created on: {{ date }}
 *      Author: AL
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#include "core-train.h"
#include "core-routes.h"
#include "core-utils.h"

#include "JDEC.h"
#include "flash.h"

/*
 * test
 */
#define CS_L
#define CS_H
#define WP_H	//GPIO_WP_FLASH->BRR |= PIN_WP_FLASH;
//#define _flashWriteByte(byte)
//#define _flashReadByte()
//#define _flashWrite(buf,len)
//#define _flashRead(buf,len)

uint8_t flashTestArray[1280];
static uint32_t flashTestArrayAddr=0;


uint8_t _flashWriteByte(uint8_t byte){
	return 0;
}
uint8_t _flashReadByte(void){
	static uint8_t iStatus;
	return iStatus++;
}
uint8_t _getFlashReadStatus(void){
	static uint8_t iStatus;
	return iStatus++;
}
uint8_t _getFlashWriteStatus(void){
	static uint8_t iStatus;
	return iStatus++;
}
void _flashWrite(uint8_t *buf,uint32_t len){
	memcpy(&flashTestArray[flashTestArrayAddr],buf,len);
}
void _flashRead(uint8_t *buf,uint32_t len){
	memcpy(buf,&flashTestArray[flashTestArrayAddr],len);
}


uint8_t getFlashStatus(void){
	CS_L;
	_flashWriteByte(READ_STATUS_REGISTER);
	uint8_t status = _flashReadByte();
	CS_H;
	return status;
}

void setWriteEn(uint8_t isSet){
	CS_L;
	if(isSet)_flashWriteByte(WRITE_ENABLE);
	else _flashWriteByte(WRITE_DISABLE);
	CS_H;
}

uint8_t readSerial(Jedec_st* data){
	uint8_t status = getFlashStatus();
	if(STATUS_REGISTER_WIP&status) return status;
	CS_L;
	_flashWriteByte(READ_IDENTIFICATION_H);
	uint8_t len = sizeof(Jedec_st);
	uint8_t *buf = (uint8_t*)data;
	while(len--){
		(*buf++)=_flashReadByte();
	}
	CS_H;

	return 0;
}


/*
 * Warning! Erase flash sectors before write new data
 */
uint8_t writeFlash(uint8_t* buf, uint32_t adr, uint16_t len){
	static WriteStatus_en status = init;

	switch(status){
		default:
			status = error;
		break;
		case error:
			status = init;
		case init:
		{
			setWriteEn(SET);
			uint8_t st = getFlashStatus();
			if( (STATUS_REGISTER_WEL&st)==0 ) return error;
			if( STATUS_REGISTER_WIP&st ) return error;
			if( STATUS_REGISTER_SWDR&st ) return error;
			CS_L;
			_flashWriteByte(PAGE_PROGRAM);
			#ifndef HAL
			flashTestArrayAddr = (uint8_t*)adr-flashTestArray;
			#endif
			_flashWriteByte(adr>>16);
			_flashWriteByte(adr>>8);
			_flashWriteByte(adr>>0);
			_flashWrite(buf,len);
			status = sendData;
		}
		case sendData:
		{
			uint8_t st = _getFlashWriteStatus();
			if(st!=write) break;
			status = write;
		}
		case write:
			CS_H;
			status = wait;

		case wait:
		{
			uint8_t st= getFlashStatus();
			if(st&STATUS_REGISTER_WIP) status = wait;
			else status = init;
			CS_L;
		}
		break;
	}

	return status;
}

uint8_t eraseFlash(void){
	static WriteStatus_en status = init;
	switch(status){
		default:
			status = error;
		break;
		case error:
			status = init;
		case init:
		{
			setWriteEn(SET);
			uint8_t st = getFlashStatus();
			if( (STATUS_REGISTER_WEL&st)==0 ) return error;
			if( STATUS_REGISTER_WIP&st ) return error;
			CS_L;
			_flashWriteByte(BULK_ERASE);
			CS_H
			#ifndef HAL
			memset(flashTestArray,0,sizeof(flashTestArray));
			#endif
			status = wait;
		}
		case wait:
		{
			uint8_t st = getFlashStatus();
			if(STATUS_REGISTER_WIP&st) status = wait;
			else status = init;
		}
		break;
	}

	return status;

}


uint8_t eraseSector(uint32_t adr){
	static WriteStatus_en status = init;
	switch(status){
		default:
			status = error;
		break;
		case error:
			status = init;
		case init:
		{
			setWriteEn(SET);
			uint8_t st = getFlashStatus();
			if( (STATUS_REGISTER_WEL&st)==0 ) return error;
			if( STATUS_REGISTER_WIP&st ) return error;
			CS_L;
			_flashWriteByte(SECTOR_ERASE);
			_flashWriteByte(adr>>16);
			_flashWriteByte(adr>>8);
			_flashWriteByte(adr>>0);
			CS_H
			#ifndef HAL
			memset(&flashTestArray[SECTOR_SIZE*adr],0xff,SECTOR_SIZE);
			#endif
			status = wait;
		}
		case wait:
		{
			uint8_t st = getFlashStatus();
			if(st&STATUS_REGISTER_WIP) status = wait;
			else status = init;
			break;
		}
	}

	return status;
}

uint8_t readFlash(uint8_t *buf, uint32_t adr, uint16_t len){
	static WriteStatus_en status = init;

	switch(status){
		default:
			status = error;
		break;
		case error:
			status = init;
		case init:
		{
			setWriteEn(SET);
			uint8_t st = getFlashStatus();
			if( STATUS_REGISTER_WIP&st ) return error;
			CS_L;
			_flashWriteByte(READ_DATA_BYTES_HS);
			_flashWriteByte(adr>>16);
			_flashWriteByte(adr>>8);
			_flashWriteByte(adr>>0);
			_flashWriteByte(0xFF);
			#ifndef HAL
			flashTestArrayAddr = (uint8_t*)adr-flashTestArray;
			#endif
			_flashRead(buf,len);
			status = sendData;
		}
		case sendData:
			status = (WriteStatus_en)_getFlashReadStatus();
			if(status!=write) break;

		case write:
			CS_H;
			status = init;
		break;
	}

	return status;
}



void changeProtection(uint8_t isWp){
	static WriteStatus_en status = init;

	switch(status){
		default:
			status = error;
		break;
		case error:
			status = init;
		case init:
			setWriteEn(SET);
			CS_L;
			_flashWriteByte(WRITE_STATUS_REGISTER);
			if(isWp){
				_flashWriteByte(status);
				WP_H;
			}
			else{
				_flashWriteByte(0x0);
			}
			CS_H;
			status = wait;

		case wait:
		{
			uint8_t st = getFlashStatus();
			if(STATUS_REGISTER_WIP&st) status = wait;
			else status = init;
		}
		break;
	}
}


