/*
 * udp.c
 * Autogenerated code from TrainFramework
 *
 *  Created on: 2019-10-04T07:59:49.434Z
 *      Author: AL
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#include "core-train.h"
#include "core-routes.h"
#include "core-utils.h"

#include "udp.h"
#include "json.h"
#include "files.h"
#include "snmp.h"

#ifdef WIN32
#include 	<windows.h>
#include	<winsock2.h>
#include 	<ws2tcpip.h>
#endif

#define DEBUG_TRACE
#ifdef DEBUG_TRACE
	#define TRACE(trace)	do{\
								trace;\
							}while(0)
#else
	#define TRACE(trace)
#endif


int initUdp(void){
	#ifdef WIN32
	WSADATA wsa;
	if (WSAStartup(MAKEWORD(2,2),&wsa) != 0){
		printf("Failed. Error Code : %d\n",WSAGetLastError());
		return EXIT_FAILURE;
	}
	#endif
	return EXIT_SUCCESS;
}


int initUdpClient(uint32_t inetAddress,uint16_t port, uint8_t protocol){
	#ifdef WIN32
	// Create a SOCKET for connecting to server
	struct sockaddr_in service;
	service.sin_family = AF_INET;
	service.sin_addr.s_addr = inetAddress;
	service.sin_port = htons(port);
	//create socket
	static SOCKET udpConnectSocket=INVALID_SOCKET;
	udpConnectSocket=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	if (udpConnectSocket == INVALID_SOCKET) {
		printf("Error at socket(): %d\n", WSAGetLastError());
		WSACleanup();
		return 1;
	}

	int i=1;
	setsockopt(udpConnectSocket,SOL_SOCKET,SO_REUSEADDR,(char *)&i,sizeof (i));
	//bind socket
	if(bind(udpConnectSocket, (SOCKADDR *) &service, sizeof (service))== SOCKET_ERROR){
		printf("bind failed with error %u\n", WSAGetLastError());
		return INVALID_SOCKET;
	}

	#endif
	return udpConnectSocket;
}


Parcel_st udpParcel[4];
Train_st udpTrain;
void udpStationInit(void){
	fillDepot(&udpTrain);
	udpTrain.box = malloc(sizeof(Parcel_st*)*4);
	for(uint16_t iParcel=0;iParcel<4;iParcel++){
		udpTrain.box[iParcel] = (Parcel_st*)&udpParcel[iParcel];
	}
	udpTrain.capacity = 4;
	udpTrain.route = ROUTE_UDP;
}

/*
 * TCP Railway Station
 */
int udpStation(void *p){
	//Parcel_st *box = meetTrain(&udpTrain);
	uint16_t iBox = meetTrainBox(&udpTrain,0);
	Parcel_st *box = udpTrain.box[iBox];
	while(box){
		if(iBox>udpTrain.capacity) return EXIT_SUCCESS;
		printf("\nTCP Station\n");
		printf("\t%p %d %p\n",box,iBox,&udpParcel[iBox]);
		static void *car;
		car = box->parcel;

		try((car),"\tempty car on tcp train",EXIT_FAILURE);
		int socket = 0;
		try(( ((RailUdp_st*)car)->socket ),"\tInvalid socket",EXIT_FAILURE);
		socket = ((RailUdp_st*)car)->socket;
		uint8_t i=0,slen;
		struct sockaddr_in* sadr;
		while(car){
			TRACE(printf("\tCar number %d command (Hitch_st) %I64u\n",i,((Hitch_st *)car)->command););
			if((0 == i) & ( 0 == ((RailUdp_st *)car)->command )){
				sadr = ((RailUdp_st *)car)->saddr;
				slen = ((RailUdp_st *)car)->slen;
			}
			

			else if( (1 == i) & ( COMMAND_SNMP_RESPONSE == ((RailSnmp_st *)car)->command ) ){
				TRACE(printf("\tCOMMAND_SNMP_RESPONSE load\n"););
				
				RailSnmp_st *railSnmp = ((RailSnmp_st *)car);
				
				static RailUdp_st railUdp_0={NULL};
				try( (railSnmp), "\tthe rails RailSnmp_st do not go to udpStation\n", EXIT_FAILURE );
				
				
				railUdp_0.response = (uint8_t*)railSnmp->response;
				railUdp_0.respLen = railSnmp->respLen;
				TRACE(printf("\tSend response:\n\t\t%d bytes\n\t\t%s\n",railUdp_0.respLen,railUdp_0.response););
				for(int l=0;l<railUdp_0.respLen;l++){
					TRACE(printf("0x%02X ",railUdp_0.response[l]););
				}
				TRACE(printf("\n"););
				


				
				/*
				 * send response to TCP client or
				 * send request to TCP server
				 */
				try( (socket), "\tthe rails RailSnmp_st do not go to udpStation\n", EXIT_FAILURE );
				TRACE(printf("\t\tTo %s:%d\n\n",inet_ntoa(sadr->sin_addr), ntohs(sadr->sin_port)););
				sendto(
					socket,
					(char*)railUdp_0.response,
					railUdp_0.respLen,
					0,
					(struct sockaddr*)sadr,
					slen
				);
				
				((RailSnmp_st *)car)->command = 0;
			}

			

			else if( (0 == i) & ( COMMAND_READ == ((RailUdp_st *)car)->command ) ){
				TRACE(printf("\tCOMMAND_READ load\n"););
				
				RailUdp_st *railUdp = ((RailUdp_st *)car);
				
				static RailUdp_st railUdp_1={NULL};
				try( (railUdp), "\tthe rails RailUdp_st do not go to udpStation\n", EXIT_FAILURE );
				
				
				


				
				
				/*
				 * send message to TCP observers
				 * example  railTcp->to_port=80 send message to ROUTE_HTTP
				 */
				railUdp->car = &railUdp_1;
				sendTrainsFromDepot(ROUTE_UDP,railUdp->packet->tPort,box->parcel);
				
				((RailUdp_st *)car)->command = 0;
			}

			

			car = ((Hitch_st*)car)->car;
			i++;
		}

		//box=meetTrain(&udpTrain);
		iBox = meetTrainBox(&udpTrain,iBox);
		box = udpTrain.box[iBox];
	}
	return EXIT_SUCCESS;
}
